# 4.1 변수란 무엇인가? 왜 필요한가?

```json
10 + 20
```

자바스크립트 엔진이 위 코드를 계산(평가)하려면 먼저 10, 29, + 라는 기호(리터럴literal과 연산자operator)의 의 의미를 알고있어야 하며 10 + 20 이라는 식(표현식 expression) 의 이미도 해석(파싱)할 수 있어야 한다.

숫자 값은 메모리 상의 임의의 위치(메모리 주소)에 저장되고, CPU는 이 값을 읽어들여 연산을 수행한다. 이 때 2진수로 저장된다.

메모리에 저장된 정보를 재사용 한다면 메모리 주소를 통해 메모리 공간에 직접 접근하는 것 외에는 방법이 없다. 하지만 직접 접근하면 치명적 오류를 발생시킬 수 있다. 따라서 자바스크립트는 개발자의 메모리 제어를 허용하지 않는다. 이를 극복하기 위해 변수를 사용한다.

**변수란?**

- 하나의 값을 저장하기 위해 확보한 메모리 공간
- 저장한 값의 위치를 가리키는 상징적인 이름

**변수의 실행**

컴파일러 또는 인터프리터에 의해, 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.

# 4.2 식별자

**식별자란?**

- 메모리 상에 존재하는 어떤 값을 구별해서 식별할 수 있는 고유한 이름
    - ex) 변수, 함수, 클래스 등의 모든 이름
- **값**이 아니라 **메모리 주소**를 기억함
- 선언으로 자바스크립트 엔진에 식별자의 존재를 알림

# 4.3 변수 선언

변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

- 변수를 생성하는 것. 즉 값을 저장할 수 있게 준비하는 것.
- 값을 저장하기 위한 메모리 공간을 확보 → 변수 이름과 확보된 메모리 공간의 주소를 연결
- var, let, const 사용

> **var의 단점**

블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다. 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생할 수 있다.
![[Pasted image 20240610101407.png]]

> **키워드**

키워드는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어다. 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. 예를들어, var 키워드를 만나면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다.

```jsx
var score;
```

위 변수 선언문은 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.

**변수 선언 2단계**

1. 선언 단계 : 변수 이름 등록
2. 초기화 단계 : 값을 저장하기 위한 메모리 공간 확보 → undefined를 할당해 초기화

> **undefined**

undefined는 자바스크립트에서 제공하는 원시 타입의 값이다.

> JavaScript에서 **`undefined`**는 선언되었으나 값이 할당되지 않은 변수의 초기값이거나, 존재하지 않는 객체의 속성이나 배열의 요소에 접근했을 때 반환되는 값을 나타내는 데이터 타입입니다.

> **변수 등록 위치**

모든 식별자는 **실행 컨텍스트**에 등록된다. **자바스크립트 엔진**은 **실행 컨텍스트**를 통해 식별자와 스코프를 관리한다. 실행 컨텍스트는 자바스크립트 엔진이 변수를 관리할 수 있도록, 변수의 존재를 알린다.

**실행 컨텍스트** 자바스크립트 엔진이 코드를 실행하기 위해 필요한 환경을 제공하고, 코드의 실행 순서와 결과를 관리하는 영역이다.

---
![[Pasted image 20240610101500.png]]
# 4.4 변수 선언의 실행 시점과 변수 호이스팅

결론 : 모든 선언문은 런타임 이전 단계에서 먼저 실행된다.

런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점) 이전 단계에서 변수 선언이 먼저 실행되기 때문에, ReferenceError 대신 undefined가 출력됨

```jsx
console.log(score); // undefined
var score; // 변수 선언
```

> **소스코드 평가 과정**

런타임(소스코드를 한 줄씩 실행)하기 전에, 소스코드 평가 과정을 거친다. 이 때 자바스크립트 엔진은 모든 선언문(변수 선언문, 함수 선언문)을 먼저 실행한다.

## 변수 호이스팅

- 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징

# 4.5 값의 할당

변수에 값을 할당(대입, 저장)할 때는 할당 연산자를 사용한다.

변수 선언과 값의 할당을 하나의 문(statement)으로 단축 표현할 수도 있다.

```jsx
var score = 80;
```

자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.

**주의**🤚🏻

- 변수 선언과 값의 할당의 실행 시점이 다르다.
- **변수 선언**은 소스코드가 순차적으로 실행되는 시점인 **런타임 이전**에 먼저 실행되지만 **값의 할당**은 소스코드가 순차적으로 실행되는 시점인 **런타임에 실행**된다.
- **변수에 값을 할당할 때에는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 값 80을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 할당값 80을 저장한다.**
![[Pasted image 20240610102126.png]]
# 4.6 값의 재할당

변수에 새로운 값을 재할당하는 것

- 변수 : 변수에 저장된 값 변경 가능
- 상수 : 값을 재할당할 수 없음

**var :** 재할당 가능

**const :** 재할당 금지 (상수 표현)

```tsx
var score = 80;
score = 90;
```
![[Pasted image 20240610101815.png]]
위의 더 이상 필요없는 `undefined`, 80은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. (해제 타이밍은 알 수 없다.)

> **가비지 콜렉터**

- 애플리케이션이 할당한 메모리 공간을 주기적으로 검사 → 더 이상 사용되지 않는 (어떠한 식별자도 참조하지 않는) 메모리 해제
- 효과 : 메모리 누수 방지

> **매니지드 언어** ← Javascript, Java, Python, C#

- 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당 (가비지 콜렉터)
- 개발자의 직접적인 메모리 제어 불허

**언매니지드 언어** ← C, C++

- 메모리 제어를 개발자가 주도 가능 (malloc 등)
- 개발자의 역량에 따라 최적의 성능 확보 가능 BUT 치명적 오류 생산 가능성 존재…

# 4.7 식별자 네이밍 규칙

- 식별자는 문자, 숫자, _, $ 가능 (특수문자 불허)
- 식별자는 문자, ~~숫자~~, _, $ 으로 시작해야 함 (특수문자, 숫자 불허)
- 예약어 사용 불가

> 예약어

A await B break C case, catch, class, const, continue D debugger, default, delete, do E else, enum, export, extends F false, finally, for, function G H I if, implements, import, in, instanceof J K L M N O P potected, public Q R return S super, static, switch T this, throw, true, try, typeof U V var, void W while, with V Y yield Z

- 다수의 변수를 한번에 선언 가능 (권장X)

```tsx
var person1, person2, person3, ...
```

- 한글, 일본어 식별자 사용 가능 (권장X)
- 대소문자 구별함

```tsx
var firstname, firstName, FIRSTNAME; // 서로 다른 변수다.
```

## 네이밍 컨벤션

- 변수명, 함수명 → **camelCase**
- 클래스명, 생성자 함수 → **PascalCase**

```tsx
var firstName; // camelCase
var FirstName; // PascalCase
var first_name; // snake_case
var strFirstName; // typeHungarianCase 헝가리언케이스
```

- DOM 노드 네이밍 컨벤션
    
    - camelCase 사용
    - jQuery에서는 **`$`** 기호를 사용하여 jQuery 객체를 반환한다. `var $myDiv = $('#myDiv');` 그래서 **`$`**접두사를 이용해 해당 변수가 jQuery 객체임을 암시할 수 있다.
    - 그러나 JavaScript에서 DOM 요소를 조작할 때는 **`$`** 접두사 사용이 일반적이지 않다.
- RxJS 옵저버블
    
    - camelCase 사용
    - `$` 접미사 사용 ****: RxJS와 같은 반응형 프로그래밍 라이브러리에서는 **`$`** 접미사를 사용하여 옵저버블 변수를 명시하는 것이 일반적이다.
        - ~~그런데 아래의 공식문서를 보면 더 이상 관례가 아닌 것 같기도 함…~~
        - [https://junwoo45.gitbook.io/learn-rxjs-korean/learn-rxjs/concepts/rxjs-primer](https://junwoo45.gitbook.io/learn-rxjs-korean/learn-rxjs/concepts/rxjs-primer)
    
    ```tsx
    var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
    ```