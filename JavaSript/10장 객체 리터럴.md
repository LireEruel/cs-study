# 10.1 객체란?

자바스크립트는 객체 기반의 프로그래밍 언어이다. 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.

- 원시 값은 변경 불가능한 단 하나의 값만 나타낸다.
- 객체는 변경 가능한 값이다. 키와 값으로 구성된 0개 이상의 프로퍼티로 이루어져 있다.

<aside> 💡 **프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.**

</aside>
![[Pasted image 20240610120549.png]]
객체는 객체의 상태를 나타내는 값(프로퍼티)과 프로퍼티를 참조하고 조작할 수 있는 동작(메서드)를 모두 포함할 수 있다.

> 자바스크핍트에서는 함수와 객체는 분리해서 생각할 수 없는 개념이다. 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 하다.

**객체 지향 프로그래밍** : 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

# 10.2 객체 리터럴에 의한 객체 생성

자바스크립트는 `프로토타입` 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)
 
 💡 가장 일반적이고 간단한 방법 → 객체 리터럴 사용  ([[5장 표현식과 문#5.2 리터럴]])


  
**리터럴 →** 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법

객체 리터럴은 중괄호내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성한다.

```jsx
var person = {
name: "lee",
sayHello: function() {
	console.log("hello my name is ${this.lee});
}

const empty = {} //object
```

# 10.3 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

프로퍼티 키는 값에 접근할 수 있는 식별자 역할을 한다.

```jsx
var person = {
	name: 'Lee',
	age: 20
}
```

# 10.4 메서드

자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다.

함수는 객체(일급 객체)다. 따라서 함수는 프로퍼티 값으로 사용할 수 있다. **프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다.**

```jsx
 var circle = {
	 radius: 5, // 프로퍼티
	 
	 getDiameter: function () { // 메서드
		 return 2 * this.radius;  // this는 circle을 가리킴
	 }
 };
```

# 10.5 프로퍼티 접근

프로퍼티에 접근하는 방법은 두 가지다.

- 마침표 프로퍼티 접근 연산자(`.`)를 사용하는 **마침표 표기법**
- 대괄호 프로퍼티 접근 연산자 (`[…]`)를 사용하는 **대괄호 표기법**

대괄호 표기법을 사용하는 경우 **대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열**이어야 한다.

```jsx
var person = {
	'last-name' : 'Lee'
}

person.last-name; // Node.js 환경 : ReferenceError : name is not defined
                  // 브라우저 환경 : NaN
```

### person.last-name이 Node.js와 브라우저가 다른 이유

- js 엔진은 먼저 `person.last`를 평가한다. - > `undefined - name`과 같다.
- **Node.js** 에서는 `name`이 어디에도 없으니 `name is not defined` 에러가 발생한다.
- **브라우저**에서는 `name`이라는 전역변수(`window`의 프로퍼티)가 존재한다. `name`의 기본값은 빈 문자열이다. 따라서 `undefined - ''` 와 같으므로 `NaN`이 된다.

# 10.6 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신된다.

# 10.7 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면, 프로퍼티가 동적으로 생성 & 값이 할당된다.

```jsx
var person = {
	name: 'Lee'
}

person.age = 20; // age: 20 이라는 프로퍼티가 동적으로 생성되고 값이 할당된다.
```

# 10.8 프로퍼티 삭제

delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다.

<aside> 💡 **존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시된다.**

</aside>

```jsx
var person = {
	name: 'Lee'
}

delete person.age; // age 프로퍼티가 존재하지 않는다. **이때 에러가 발생하지 않는다.**
```

# 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

## 10.9.1 프로퍼티 축약 표현

ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키 이름이 동일할 때 프로퍼티 키를 생략할 수 있다. 프로퍼티 키는 변수 이름으로 자동 생성된다.

```jsx
var obj = { // 프로퍼티 값으로 변수를 사용하였다. 그리고 변수 이름과 프로퍼티 키 이름이 동일하다.
	x: x,
	y: y
}

var obj = { x, y }; // 프로퍼티 축약 표현이 적용된 것으로, 위와 같다.
```

## 10.9.2 계산된 프로퍼티 이름

문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다. 단, 프로퍼티 키로 사용할 표현식을 대괄호(`[…]`)로 묶어야 한다.

이를 계산된 프로퍼티 이름이라 한다.

ES5에서 계산된 프로퍼티 이름으로 프로퍼티 키를 **동적 생성**하려면 객체 리터럴 외부에서 대괄호(`[…]`) 표기법을 새용해야 한다.

```jsx
// ES5
var prefix = 'prop'

var i = 0;
obj[prefix + '-' + ++i] = i;

// ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성 가능
const obj = {
	[`${prefix}-${++i}`]: i,
}
```

## 10.9.3 메서드 축약 표현

ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.

메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.

```jsx
var obj = {
	name: 'Lee',
	sayHello: function() {  // 메서드 축약 표현X
		console.log('Hi!' + this.name);
	},
	sayHi() {               // 메서드 축약 표현O
		console.log('Hi!' + this.name);
	}
}
```